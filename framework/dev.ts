import * as colors from '@std/fmt/colors';
import { SEPARATOR } from '@std/path/constants';
import { FsContext } from './lib/fs_context.ts';
import {
  AppConfigDev,
  CookedFiles,
  Interceptors,
  InterceptorsMap,
  Manifest,
  Mode,
  PageConfig,
  PageModule,
  RouteImportMapEntry,
} from './types.ts';
import { relative } from '@std/path/relative';
import { exists } from '@std/fs/exists';
import { EOL } from '@std/fs/eol';
import { formatFiles } from './utils/fmt.ts';
import { toFileUrl } from '@std/path/to-file-url';
import { buildCollections } from './collections/index.ts';
import { Builder } from './plugins/core/builder.ts';
import { createDirectoryIfNotExists } from './utils/fs.ts';
import {
  extractInterceptors,
  findRouteInterceptors,
  iterateManifestRoutes,
} from './server/routes.ts';
import { loadModule } from './utils/load_module.ts';
import { join } from '@std/path/join';
import { walk } from '@std/fs/walk';
import { resolve } from '@std/path/resolve';
import * as esbuild from 'esbuild';
import { verifyMetadata } from './server/metadata.ts';
import { denoPlugins } from '@luca/esbuild-deno-loader';
import { createHash } from './utils/crypto.ts';
import { executionContext } from './server/index.ts';
import {
  ModuleKind,
  ModuleResolutionKind,
  Project,
  ScriptTarget,
  ts,
} from 'ts-morph';
import { basename } from '@std/path/basename';
import { extname } from '@std/path/extname';

async function generateManifest(
  { fsContext }: {
    fsContext: FsContext;
  },
): Promise<Manifest> {
  const routes = await Array.fromAsync(fsContext.walkRoutes());
  const rootDir = fsContext.resolvePath('.');

  const castPath = (filePath: string) =>
    '.' + SEPARATOR + relative(rootDir, filePath);

  const routesEntries = routes.map((
    route,
  ) => [castPath(route.path), createHash()]);

  const collectionsConfigFile = fsContext.resolvePath(
    'collections',
    'config.ts',
  );
  const collectionsCfgExists = await exists(
    collectionsConfigFile,
  );

  const imports: string[] = [];

  for (const [index, [path]] of routesEntries.entries()) {
    imports.push(
      `import * as R${index} from "${path}"`,
    );
  }

  if (collectionsCfgExists) {
    imports.push(
      `import * as collectionsConfig from "${castPath(collectionsConfigFile)}"`,
    );
  }

  const routesContent = routesEntries.map(([path, hash], index) =>
    `"${path}": ["${hash}", R${index}],`
  );

  const content = `
    // DO NOT EDIT THIS FILE. This file is generated by the framework.
    import type { Manifest } from "@sloth/core";

    ${imports.join(EOL)}

    export const manifest = {
      importMeta: import.meta,
      routes: { ${routesContent.join(EOL)} },
      collections: {
        config: ${collectionsCfgExists ? 'collectionsConfig' : '{config:{}}'},
      }
    } satisfies Manifest;
  `;

  const outFile = fsContext.resolvePath('manifest.gen.ts');

  await Deno.remove(outFile).catch(() => null);
  await Deno.writeTextFile(outFile, content);

  await formatFiles({
    entryFiles: [outFile],
    target: 'Manifest',
  });

  const mod = await import(toFileUrl(outFile).href);

  executionContext.isDev = true;

  return mod.manifest as Manifest;
}

async function bundleClientSideRouteFiles(
  { manifest, interceptorsMap, fsContext }: {
    manifest: Manifest;
    fsContext: FsContext;
    interceptorsMap: InterceptorsMap;
  },
): Promise<{ filesToFormat: string[]; filesToBundle: string[] }> {
  const routesIter = iterateManifestRoutes({
    fsContext,
    manifest,
    options: {
      omitWellKnownFiles: true,
    },
  });

  const filesToFormat: string[] = [];
  const filesToBundle: string[] = [];

  for (
    const { absRouteFilePath, relativePath, hash } of routesIter
  ) {
    const routeInterceptors = findRouteInterceptors(
      relativePath,
      interceptorsMap,
    );

    const { hydration } = await createHydrationFile({
      hash,
      fsContext,
      routeFileAbsPath: absRouteFilePath,
      interceptors: routeInterceptors,
    });

    if (hydration) {
      filesToFormat.push(hydration);
      filesToBundle.push(hydration);
    }
  }

  return { filesToFormat, filesToBundle };
}

async function bundleClientSideAssets({
  fsContext,
  manifest,
  mode,
  define = {},
  external = [],
}: {
  fsContext: FsContext;
  manifest: Manifest;
  mode: Mode;
  external?: esbuild.BuildOptions['external'];
  define?: esbuild.BuildOptions['define'];
}) {
  const rawSsrDir = fsContext.resolveFromOutDir('routes');
  const clientBuildOutDir = fsContext.resolveFromOutDir('static');

  await Promise.all([
    createDirectoryIfNotExists(rawSsrDir),
    createDirectoryIfNotExists(clientBuildOutDir),
  ]);

  const interceptorsMap = extractInterceptors({
    fsContext,
    manifest,
  });

  const { filesToBundle: postsToBundle, filesToFormat } =
    await buildCollections({
      fsContext,
    });

  await prepareClientCode({ manifest, fsContext });

  const { filesToBundle: routesToBundle, filesToFormat: routesToFormat } =
    await bundleClientSideRouteFiles({
      manifest,
      fsContext,
      interceptorsMap,
    });

  await formatFiles({
    entryFiles: [...routesToFormat, ...filesToFormat],
    target: 'Client Side Assets',
  });

  await bundleClient({
    mode,
    fsContext: fsContext,
    entryPoints: [
      ...routesToBundle,
      ...postsToBundle,
      import.meta.resolve('./browser/hot_reload.ts'),
    ],
    outDir: fsContext.resolveFromOutDir('static'),
    external,
    define: {
      ...define,
      'globalThis.BUILD_TIME': JSON.stringify(true),
    },
  });

  await bundleAssets(fsContext);
}

async function build({ fsContext, manifest, config, mode }: {
  fsContext: FsContext;
  manifest: Manifest;
  config: AppConfigDev;
  mode: Mode;
}) {
  const outDir = fsContext.resolveFromOutDir('.');

  await Deno.remove(outDir, { recursive: true }).catch(() => null);
  await Deno.mkdir(outDir, { recursive: true }).catch(() => null);

  using builder = new Builder(fsContext);

  config.plugins?.forEach((plugin) => plugin.setup(builder));

  await bundleClientSideAssets({
    fsContext,
    manifest,
    mode,
    ...config.esbuildConfig,
  });

  await builder.wg.wait();

  await Promise.all(
    ['client', 'collections', 'routes'].map((dir) =>
      Deno.remove(fsContext.resolveFromOutDir(dir), { recursive: true }).catch(
        () => null
      )
    ),
  );
}

export default async function (config: AppConfigDev) {
  const isBuild = Deno.args.includes('--build');
  const fsContext = new FsContext(config.baseUrl);
  const manifest = await generateManifest({ fsContext });
  await build({
    fsContext,
    manifest,
    config,
    mode: isBuild ? 'production' : 'development',
  });
  if (!isBuild) {
    const mainModule = new URL(config.entryPoint, config.baseUrl).href;
    await import(mainModule);
  }
}

async function createHydrationFile({
  hash,
  routeFileAbsPath,
  fsContext,
  interceptors,
}: {
  hash: string;
  routeFileAbsPath: string;
  fsContext: FsContext;
  interceptors: Interceptors[];
}): Promise<
  & Omit<
    RouteImportMapEntry,
    'interceptors' | 'layouts' | 'middlewares' | 'path'
  >
  & {
    pageConfig: PageConfig;
  }
> {
  const cookedFilePath = fsContext.resolveFromOutDir('client', hash + '.jsx');

  const { metadata, pageConfig } = await loadModule<PageModule>(
    routeFileAbsPath,
  );

  const outDir = fsContext.resolveFromOutDir('routes');

  try {
    await verifyMetadata(metadata);
  } catch (error) {
    console.log(
      colors.red(`Invalid metadata object found at ${routeFileAbsPath}\n`),
    );
    throw error;
  }

  const { ssrOnly = false } = pageConfig ?? {};

  let hydrationFilePath: string | undefined;

  if (!ssrOnly) {
    const layouts = interceptors
      .filter(({ layout }) => Boolean(layout))
      .map(({ layout }) => ({ importPath: layout!.path, hash: layout!.hash }));

    const bootstrapMod = import.meta.resolve('./browser/bootstrap.ts');
    hydrationFilePath = join(outDir, `${hash}.tsx`);
    const hydrationFileContent = `
    import type { LayoutProps } from "@sloth/core";
    import type { ComponentType } from "preact";
    import { bootstrap } from "${bootstrapMod}";
    import { default as Page } from "${toFileUrl(cookedFilePath)}";
    
    ${
      pageConfig?.skipInheritedLayouts ? '' : layouts
        .map(
          (layout, index) =>
            `import { default as Layout$${index} } from "${
              toFileUrl(
                fsContext.resolveFromOutDir('client', layout.hash + '.jsx'),
              )
            }";`,
        )
        .join('\n')
    }

    const layouts = ${
      pageConfig?.skipInheritedLayouts ? '[]' : `[
              ${
        layouts
          .map(
            (layout, index) =>
              `{ Layout: Layout$${index} as ComponentType<LayoutProps>, hash: "${layout.hash}" }`,
          )
          .join(',')
      }
            ]`
    };

    bootstrap({ Page, hash: "${hash}", layouts });
  `;

    await Deno.writeTextFile(hydrationFilePath, hydrationFileContent);
  }

  return {
    hydration: hydrationFilePath,
    hash,
    pageConfig: pageConfig ?? {},
  };
}

async function bundleAssets(context: FsContext) {
  await Promise.all([
    copyPublicFiles(context),
  ]);
}

async function copyPublicFiles(context: FsContext): Promise<void> {
  const publicDir = context.resolvePath('public');
  const publicDirExits = await exists(publicDir);

  if (!publicDirExits) {
    return;
  }

  const outDir = context.resolveFromOutDir('static');

  for await (const file of walk(publicDir, { includeDirs: false })) {
    const relativePath = relative(publicDir, file.path);
    const outDirDir = join(outDir, relativePath.slice(0, -file.name.length));
    await Deno.mkdir(outDirDir, {
      recursive: true,
    });
    await Deno.copyFile(file.path, resolve(outDir, relativePath));
  }
}

async function bundleClient({
  entryPoints,
  define = {},
  outDir,
  plugins = [],
  fsContext,
  alias,
  mode,
  external = [],
}: {
  entryPoints: string[];
  outDir: string;
  fsContext: FsContext;
  define?: Record<string, string>;
  plugins?: esbuild.Plugin[];
  alias?: Record<string, string>;
  mode: Mode;
  external?: string[];
}): Promise<CookedFiles> {
  await createDirectoryIfNotExists(outDir);

  const absWorkingDir = fsContext.resolvePath('.');

  const result = await esbuild.build({
    plugins: [
      ...plugins,
      ...denoPlugins({
        configPath: fsContext.resolvePath('./deno.json'),
      }),
    ],

    absWorkingDir,

    platform: 'browser',

    format: 'esm',
    target: 'esnext',

    splitting: true,
    bundle: true,
    treeShaking: true,
    minify: true,

    sourcemap: mode === 'development',
    metafile: true,

    entryPoints,
    outdir: '.',

    legalComments: 'none',

    jsx: 'automatic',
    jsxImportSource: 'preact',

    define: {
      ...define,
    },

    alias,

    external,

    entryNames: '[name]',
    write: false,
  });

  const { outputFiles = [] } = result;

  const paths: string[] = [];
  const promises: Promise<void>[] = [];
  for (const file of outputFiles) {
    const filePath = fsContext.resolveFromOutDir(
      'static',
      relative(absWorkingDir, file.path),
    );
    promises.push(
      Deno.writeFile(filePath, file.contents, {
        createNew: true,
      }),
    );
    entryPoints.push(filePath);
  }

  await Promise.all(promises);

  await esbuild.stop();

  return paths;
}

export async function prepareClientCode({ manifest, fsContext }: {
  manifest: Manifest;
  fsContext: FsContext;
}) {
  const tmpOutDir = await Deno.makeTempDir();

  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.ESNext,
      moduleResolution: ModuleResolutionKind.NodeNext,
      module: ModuleKind.ESNext,
      jsx: ts.JsxEmit.Preserve,
      jsxImportSource: 'preact',
      outDir: tmpOutDir,
    },
  });

  for (const path of Object.keys(manifest.routes)) {
    const entryName = basename(path);

    const absEntryPath = path.slice(0, -entryName.length);

    const file = project.addSourceFileAtPath(path);

    file.getImportDeclarations().forEach((importDeclaration) => {
      const moduleSpecifier = importDeclaration.getModuleSpecifier();
      const moduleSpecifierText = moduleSpecifier.getText().slice(1, -1);
      if (moduleSpecifierText.startsWith('../')) {
        const modulePath = resolve(absEntryPath, moduleSpecifierText);
        importDeclaration.setModuleSpecifier(modulePath);
      }
    });

    file.getVariableDeclarations().forEach((v) => {
      if (v.isExported()) {
        v.remove();
      }
    });

    file.getFunctions().forEach((f) => {
      if (f.isExported() && !f.isDefaultExport()) {
        f.remove();
      }
    });

    file.getExportDeclarations().forEach((exportDeclaration) => {
      exportDeclaration.removeModuleSpecifier().remove();
    });

    file.fixUnusedIdentifiers();
  }

  await project.emit();

  const entryPoints: string[] = [];

  for await (
    const entry of walk(resolve(tmpOutDir, 'routes'), {
      match: [/\.js(x)$/],
    })
  ) {
    const containerRelativeDir = relative(
      tmpOutDir,
      entry.path.slice(0, -entry.name.length),
    );

    const extMap: Record<string, string> = {
      '.js': '.ts',
      '.jsx': '.tsx',
    };

    const jsExt = extname(entry.path);
    const tsExt = extMap[jsExt];

    const tsFilePath = entry.name.slice(0, -jsExt.length) + tsExt;

    const manifestRouteKey = `.${SEPARATOR}` + join(
      containerRelativeDir,
      tsFilePath,
    );

    if (!manifest.routes[manifestRouteKey]) {
      continue;
    }

    const [hash] = manifest.routes[manifestRouteKey];

    const outDir = fsContext.resolveFromOutDir('client');

    await createDirectoryIfNotExists(outDir);

    const outFile = join(outDir, `${hash}${jsExt}`);

    await Deno.copyFile(
      entry.path,
      outFile,
    );

    entryPoints.push(outFile);
  }

  return entryPoints;
}
