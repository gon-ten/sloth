import * as colors from '@std/fmt/colors';
import { SEPARATOR } from '@std/path/constants';
import { FsContext } from './lib/fs_context.ts';
import {
  AppConfigDev,
  CookedFiles,
  Interceptors,
  InterceptorsMap,
  Manifest,
  PageConfig,
  PageModule,
  RouteImportMapEntry,
} from './types.ts';
import { relative } from '@std/path/relative';
import { createHash } from './utils/crypto.ts';
import { exists } from '@std/fs/exists';
import { EOL } from '@std/fs/eol';
import { formatFiles } from './utils/fmt.ts';
import { toFileUrl } from '@std/path/to-file-url';
import { buildCollections } from './collections/index.ts';
import { Builder } from './plugins/core/builder.ts';
import { createDirectoryIfNotExists } from './utils/fs.ts';
import {
  extractInterceptors,
  findRouteInterceptors,
  iterateManifestRoutes,
} from './server/routes.ts';
import { loadModule } from './utils/load_module.ts';
import { join } from '@std/path/join';
import { bundleStyles } from './styling/bundle_styles.ts';
import { walk } from '@std/fs/walk';
import { resolve } from '@std/path/resolve';
import * as esbuild from 'esbuild';
import { verifyMetadata } from './server/metadata.ts';
import { denoPlugins } from '@luca/esbuild-deno-loader';

async function generateManifest(
  { fsContext }: {
    fsContext: FsContext;
  },
): Promise<Manifest> {
  const routes = await Array.fromAsync(fsContext.walkRoutes());
  const rootDir = fsContext.resolvePath('.');

  const castPath = (filePath: string) =>
    '.' + SEPARATOR + relative(rootDir, filePath);

  const routesEntries = routes.map((
    route,
  ) => [castPath(route.path), createHash()]);

  const collectionsConfigFile = fsContext.resolvePath(
    'collections',
    'config.ts',
  );
  const collectionsCfgExists = await exists(
    collectionsConfigFile,
  );

  const imports: string[] = [];

  for (const [index, [path]] of routesEntries.entries()) {
    imports.push(
      `import * as R${index} from "${path}"`,
    );
  }

  if (collectionsCfgExists) {
    imports.push(
      `import * as collectionsConfig from "${castPath(collectionsConfigFile)}"`,
    );
  }

  const routesContent = routesEntries.map(([path, hash], index) =>
    `"${path}": ["${hash}", R${index}],`
  );

  const content = `
    // DO NOT EDIT THIS FILE. This file is generated by the framework.
    import type { Manifest } from "@sloth/core";

    ${imports.join(EOL)}

    export const manifest = {
      importMeta: import.meta,
      routes: { ${routesContent.join(EOL)} },
      collections: {
        config: ${collectionsCfgExists ? 'collectionsConfig' : '{config:{}}'},
      }
    } satisfies Manifest;
  `;

  const outFile = fsContext.resolvePath('manifest.gen.ts');

  await Deno.writeTextFile(outFile, content);

  await formatFiles({
    entryFiles: [outFile],
    target: 'Manifest',
  });

  const mod = await import(toFileUrl(outFile).href);

  return mod.manifest as Manifest;
}

async function bundleClientSideRouteFiles(
  { manifest, interceptorsMap, fsContext }: {
    manifest: Manifest;
    fsContext: FsContext;
    interceptorsMap: InterceptorsMap;
  },
): Promise<{ filesToFormat: string[]; filesToBundle: string[] }> {
  const routesIter = iterateManifestRoutes({
    fsContext,
    manifest,
    options: {
      omitWellKnownFiles: true,
    },
  });

  const filesToFormat: string[] = [];
  const filesToBundle: string[] = [];

  for (
    const { absRouteFilePath, relativePath, hash } of routesIter
  ) {
    const routeInterceptors = findRouteInterceptors(
      relativePath,
      interceptorsMap,
    );

    const { hydration } = await createHydrationFile({
      hash,
      fsContext,
      routeFileAbsPath: absRouteFilePath,
      interceptors: routeInterceptors,
    });

    if (hydration) {
      filesToFormat.push(hydration);
      filesToBundle.push(hydration);
    }
  }

  return { filesToFormat, filesToBundle };
}

async function bundleClientSideAssets({
  fsContext,
  manifest,
}: {
  fsContext: FsContext;
  manifest: Manifest;
}) {
  const rawSsrDir = fsContext.resolveFromOutDir('routes');
  const clientBuildOutDir = fsContext.resolveFromOutDir('static');

  await Promise.all([
    createDirectoryIfNotExists(rawSsrDir),
    createDirectoryIfNotExists(clientBuildOutDir),
  ]);

  const interceptorsMap = extractInterceptors({
    fsContext,
    manifest,
  });

  const { filesToBundle: postsToBundle, filesToFormat } =
    await buildCollections({
      fsContext,
    });

  const { filesToBundle: routesToBundle, filesToFormat: routesToFormat } =
    await bundleClientSideRouteFiles({
      manifest,
      fsContext,
      interceptorsMap,
    });

  await formatFiles({
    entryFiles: [...routesToFormat, ...filesToFormat],
    target: 'Client Side Assets',
  });

  await bundleClient({
    fsContext: fsContext,
    entryPoints: [...routesToBundle, ...postsToBundle],
    outDir: fsContext.resolveFromOutDir('static'),
    define: {
      'globalThis.BUILD_TIME': JSON.stringify(true),
    },
  });

  await bundleAssets(fsContext);
}

async function build({ fsContext, manifest, config }: {
  fsContext: FsContext;
  manifest: Manifest;
  config: AppConfigDev;
}) {
  const outDir = fsContext.resolveFromOutDir('.');

  await Deno.remove(outDir, { recursive: true }).catch(() => null);
  await Deno.mkdir(outDir, { recursive: true }).catch(() => null);

  using builder = new Builder(fsContext);

  config.plugins?.forEach((plugin) => plugin.setup(builder));

  await bundleClientSideAssets({ fsContext, manifest });

  await builder.wg.wait();
}

export default async function (config: AppConfigDev) {
  const fsContext = new FsContext(config.baseUrl);
  const manifest = await generateManifest({ fsContext });
  await build({ fsContext, manifest, config });
  const mainModule = new URL(config.entryPoint, config.baseUrl).href;
  await import(mainModule);
}

async function createHydrationFile({
  hash,
  routeFileAbsPath,
  fsContext,
  interceptors,
}: {
  hash: string;
  routeFileAbsPath: string;
  fsContext: FsContext;
  interceptors: Interceptors[];
}): Promise<
  & Omit<
    RouteImportMapEntry,
    'interceptors' | 'layouts' | 'middlewares' | 'path'
  >
  & {
    pageConfig: PageConfig;
  }
> {
  const { metadata, pageConfig } = await loadModule<PageModule>(
    routeFileAbsPath,
  );

  const outDir = fsContext.resolveFromOutDir('routes');

  try {
    await verifyMetadata(metadata);
  } catch (error) {
    console.log(
      colors.red(`Invalid metadata object found at ${routeFileAbsPath}\n`),
    );
    throw error;
  }

  const { ssrOnly = false } = pageConfig ?? {};

  let hydrationFilePath: string | undefined;

  if (!ssrOnly) {
    const layouts = interceptors
      .filter(({ layout }) => Boolean(layout))
      .map(({ layout, hash }) => ({ importPath: layout!, hash }));

    const bootstrapMod = import.meta.resolve('./browser/bootstrap.ts');
    hydrationFilePath = join(outDir, `${hash}.tsx`);
    const hydrationFileContent = `
    import type { LayoutProps } from "@sloth/core/runtime";
    import type { ComponentType } from "preact";
    import { bootstrap } from "${bootstrapMod}";
    import { default as Page } from "${toFileUrl(routeFileAbsPath)}";
    
    ${
      pageConfig?.skipInheritedLayouts ? '' : layouts
        .map(
          (layout, index) =>
            `import { default as Layout$${index} } from "${
              toFileUrl(layout.importPath)
            }";`,
        )
        .join('\n')
    }

    const layouts = ${
      pageConfig?.skipInheritedLayouts ? '[]' : `[
              ${
        layouts
          .map(
            (layout, index) =>
              `{ Layout: Layout$${index} as ComponentType<LayoutProps>, hash: "${layout.hash}" }`,
          )
          .join(',')
      }
            ]`
    };

    bootstrap({ Page, hash: "${hash}", layouts });
  `;

    await Deno.writeTextFile(hydrationFilePath, hydrationFileContent);
  }

  return {
    hydration: hydrationFilePath,
    hash,
    pageConfig: pageConfig ?? {},
  };
}

async function bundleAssets(context: FsContext) {
  await Promise.all([bundleStyles(context), copyPublicFiles(context)]);
}

async function copyPublicFiles(context: FsContext): Promise<void> {
  const publicDir = context.resolvePath('public');
  const publicDirExits = await exists(publicDir);

  if (!publicDirExits) {
    return;
  }

  const outDir = context.resolveFromOutDir('static');

  for await (const file of walk(publicDir, { includeDirs: false })) {
    const relativePath = relative(publicDir, file.path);
    const outDirDir = join(outDir, relativePath.slice(0, -file.name.length));
    await Deno.mkdir(outDirDir, {
      recursive: true,
    });
    await Deno.copyFile(file.path, resolve(outDir, relativePath));
  }
}

async function bundleClient({
  entryPoints,
  define = {},
  outDir,
  plugins = [],
  fsContext,
  alias,
}: {
  entryPoints: string[];
  outDir: string;
  fsContext: FsContext;
  define?: Record<string, string>;
  plugins?: esbuild.Plugin[];
  alias?: Record<string, string>;
}): Promise<CookedFiles> {
  await createDirectoryIfNotExists(outDir);

  const absWorkingDir = fsContext.resolvePath('.');

  const result = await esbuild.build({
    plugins: [
      ...plugins,
      ...denoPlugins({
        configPath: fsContext.resolvePath('./deno.json'),
      }),
    ],

    absWorkingDir,

    platform: 'browser',

    format: 'esm',
    target: 'esnext',

    splitting: true,
    bundle: true,
    treeShaking: true,
    minify: false,

    sourcemap: true,
    metafile: true,

    entryPoints,
    outdir: '.',

    legalComments: 'none',

    jsx: 'automatic',
    jsxImportSource: 'preact',

    define: {
      ...define,
    },

    alias,

    entryNames: '[name]',
    write: false,
  });

  const { outputFiles = [] } = result;

  const paths: string[] = [];
  const promises: Promise<void>[] = [];
  for (const file of outputFiles) {
    const filePath = fsContext.resolveFromOutDir(
      'static',
      relative(absWorkingDir, file.path),
    );
    promises.push(
      Deno.writeFile(filePath, file.contents, {
        createNew: true,
      }),
    );
    entryPoints.push(filePath);
  }

  await Promise.all(promises);

  await esbuild.stop();

  return paths;
}
