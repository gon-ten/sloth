import * as colors from '@std/fmt/colors';
import { SEPARATOR } from '@std/path/constants';
import { FsContext } from './lib/fs_context.ts';
import {
  AppConfigDev,
  Interceptors,
  InterceptorsMap,
  Manifest,
  Mode,
  PageConfig,
  PageModule,
  RouteImportMapEntry,
} from './types.ts';
import { relative } from '@std/path/relative';
import { exists } from '@std/fs/exists';
import { EOL } from '@std/fs/eol';
import { formatFiles } from './utils/fmt.ts';
import { toFileUrl } from '@std/path/to-file-url';
import { buildCollections } from './collections/index.ts';
import { Builder } from './plugins/core/builder.ts';
import { createDirectoryIfNotExists } from './utils/fs.ts';
import {
  extractInterceptors,
  findRouteInterceptors,
  iterateManifestRoutes,
  wellKnownFileNames,
} from './server/routes.ts';
import { loadModule } from './utils/load_module.ts';
import { join } from '@std/path/join';
import { walk, WalkEntry } from '@std/fs/walk';
import { resolve } from '@std/path/resolve';
import * as esbuild from 'esbuild';
import { verifyMetadata } from './server/metadata.ts';
import { denoPlugins } from '@luca/esbuild-deno-loader';
import { createHash } from './utils/crypto.ts';
import { executionContext } from './server/index.ts';
import {
  IndentationText,
  ModuleKind,
  ModuleResolutionKind,
  NewLineKind,
  Project,
  QuoteKind,
  ScriptTarget,
  SourceFile,
  SyntaxKind,
  ts,
  VariableDeclarationKind,
} from 'ts-morph';
import { basename } from '@std/path/basename';
import { extname } from '@std/path/extname';
import { debounce } from '@std/async';
import { TypedEvents } from './lib/typed_events.ts';
import { LAYOUT_FILE_NAME } from './shared/constants.ts';
import { dirname } from '@std/path/dirname';

async function generateManifest(
  { fsContext }: {
    fsContext: FsContext;
  },
): Promise<Manifest> {
  const routes = await Array.fromAsync(fsContext.walkRoutesDir());
  const rootDir = fsContext.resolvePath('.');

  const castPath = (filePath: string) =>
    '.' + SEPARATOR + relative(rootDir, filePath);

  const routesEntries = routes.map((
    route,
  ) => [castPath(route.path), createHash()]);

  const collectionsConfigFile = fsContext.resolvePath(
    'collections',
    'config.ts',
  );
  const collectionsCfgExists = await exists(
    collectionsConfigFile,
  );

  const imports: string[] = [];

  for (const [index, [path]] of routesEntries.entries()) {
    imports.push(
      `import * as R${index} from "${path}"`,
    );
  }

  if (collectionsCfgExists) {
    imports.push(
      `import * as collectionsConfig from "${castPath(collectionsConfigFile)}"`,
    );
  }

  const routesContent = routesEntries.map(([path, hash], index) =>
    `"${path}": ["${hash}", R${index}],`
  );

  const content = `
    // DO NOT EDIT THIS FILE. This file is generated by the framework.
    import type { Manifest } from "@sloth/core";

    ${imports.join(EOL)}

    export const manifest = {
      importMeta: import.meta,
      routes: { ${routesContent.join(EOL)} },
      collections: {
        config: ${collectionsCfgExists ? 'collectionsConfig' : '{config:{}}'},
      }
    } satisfies Manifest;
  `;

  const outFile = fsContext.resolvePath('manifest.gen.ts');

  await Deno.remove(outFile).catch(() => null);
  await Deno.writeTextFile(outFile, content);

  await formatFiles({
    entryFiles: [outFile],
    target: 'Manifest',
  });

  const mod = await import(toFileUrl(outFile).href);

  executionContext.isDev = true;

  return mod.manifest as Manifest;
}

async function bundleClientSideRouteFiles(
  { manifest, interceptorsMap, fsContext }: {
    manifest: Manifest;
    fsContext: FsContext;
    interceptorsMap: InterceptorsMap;
  },
): Promise<{ filesToFormat: string[]; filesToBundle: string[] }> {
  const routesIter = iterateManifestRoutes({
    fsContext,
    manifest,
    options: {
      omitWellKnownFiles: true,
    },
  });

  const filesToFormat: string[] = [];
  const filesToBundle: string[] = [];

  for (
    const { absRouteFilePath, relativePath, hash } of routesIter
  ) {
    const routeInterceptors = findRouteInterceptors(
      relativePath,
      interceptorsMap,
    );

    const { hydration } = await createHydrationFile({
      hash,
      fsContext,
      routeFileAbsPath: absRouteFilePath,
      interceptors: routeInterceptors,
    });

    if (hydration) {
      filesToFormat.push(hydration);
      filesToBundle.push(hydration);
    }
  }

  return { filesToFormat, filesToBundle };
}

async function bundleClientSideAssets({
  fsContext,
  manifest,
  mode,
  define = {},
  external = [],
}: {
  fsContext: FsContext;
  manifest: Manifest;
  mode: Mode;
  external?: esbuild.BuildOptions['external'];
  define?: esbuild.BuildOptions['define'];
}) {
  const rawSsrDir = fsContext.resolveFromOutDir('routes');
  const clientBuildOutDir = fsContext.resolveFromOutDir('static');

  await Promise.all([
    createDirectoryIfNotExists(rawSsrDir),
    createDirectoryIfNotExists(clientBuildOutDir),
  ]);

  const interceptorsMap = extractInterceptors({
    fsContext,
    manifest,
  });

  const { filesToBundle: postsToBundle, filesToFormat } =
    await buildCollections({
      fsContext,
    });

  await prepareClientCode({ manifest, fsContext });

  const { filesToBundle: routesToBundle, filesToFormat: routesToFormat } =
    await bundleClientSideRouteFiles({
      manifest,
      fsContext,
      interceptorsMap,
    });

  await formatFiles({
    entryFiles: [...routesToFormat, ...filesToFormat],
    target: 'Client Side Assets',
  });

  const buildContext = await initializeBuildContext({
    mode,
    fsContext: fsContext,
    entryPoints: [
      ...routesToBundle,
      ...postsToBundle,
      import.meta.resolve('./browser/hot_reload.ts'),
    ],
    outDir: fsContext.resolveFromOutDir('static'),
    external,
    define: {
      ...define,
      'globalThis.BUILD_TIME': JSON.stringify(true),
    },
  });

  await buildContext.rebuild();

  await bundleAssets(fsContext);

  return {
    buildContext,
  };
}

async function build({ fsContext, manifest, config, mode }: {
  fsContext: FsContext;
  manifest: Manifest;
  config: AppConfigDev;
  mode: Mode;
}) {
  const outDir = fsContext.resolveFromOutDir('.');

  await Deno.remove(outDir, { recursive: true }).catch(() => null);
  await Deno.mkdir(outDir, { recursive: true }).catch(() => null);

  using builder = new Builder(fsContext);

  config.plugins?.forEach((plugin) => plugin.setup(builder));

  const { buildContext } = await bundleClientSideAssets({
    fsContext,
    manifest,
    mode,
    ...config.esbuildConfig,
  });

  await builder.wg.wait();

  return { buildContext };

  /*
  await Promise.all(
    ['client', 'routes'].map((dir) =>
      Deno.remove(fsContext.resolveFromOutDir(dir), { recursive: true }).catch(
        () => null,
      )
    ),
  );
  */
}

export default async function (config: AppConfigDev) {
  const isBuild = Deno.args.includes('--build');
  const fsContext = new FsContext(config.baseUrl);
  const manifest = await generateManifest({ fsContext });

  const { buildContext } = await build({
    fsContext,
    manifest,
    config,
    mode: isBuild ? 'production' : 'development',
  });

  const watcher = new BuildWatcher(fsContext.resolvePath('.'));

  /*
  watcher.on('change', async (event) => {
    if (event.kind === 'modify') {
      const [path] = event.paths;
      const ext = extname(path);
      if (ext === '.ts' || ext === '.tsx') {
        await buildContext.rebuild();
      }
    }
  });

  watcher.watch();
  */

  const buildCtx = new BuildContext(fsContext);

  await buildCtx.initialize();

  if (!isBuild) {
    const mainModule = new URL(config.entryPoint, config.baseUrl).href;
    await import(mainModule);
  }
}

async function createHydrationFile({
  hash,
  routeFileAbsPath,
  fsContext,
  interceptors,
}: {
  hash: string;
  routeFileAbsPath: string;
  fsContext: FsContext;
  interceptors: Interceptors[];
}): Promise<
  & Omit<
    RouteImportMapEntry,
    'interceptors' | 'layouts' | 'middlewares' | 'path'
  >
  & {
    pageConfig: PageConfig;
  }
> {
  const cookedFilePath = fsContext.resolveFromOutDir('client', hash + '.jsx');

  const { metadata, pageConfig } = await loadModule<PageModule>(
    routeFileAbsPath,
  );

  const outDir = fsContext.resolveFromOutDir('routes');

  try {
    await verifyMetadata(metadata);
  } catch (error) {
    console.log(
      colors.red(`Invalid metadata object found at ${routeFileAbsPath}\n`),
    );
    throw error;
  }

  const { ssrOnly = false } = pageConfig ?? {};

  let hydrationFilePath: string | undefined;

  if (!ssrOnly) {
    const layouts = interceptors
      .filter(({ layout }) => Boolean(layout))
      .map(({ layout }) => ({ importPath: layout!.path, hash: layout!.hash }));

    const bootstrapMod = import.meta.resolve('./browser/bootstrap.ts');
    hydrationFilePath = join(outDir, `${hash}.tsx`);
    const hydrationFileContent = `
    import type { LayoutProps } from "@sloth/core";
    import type { ComponentType } from "preact";
    import { bootstrap } from "${bootstrapMod}";
    import { default as Page } from "${toFileUrl(cookedFilePath)}";
    
    ${
      pageConfig?.skipInheritedLayouts ? '' : layouts
        .map(
          (layout, index) =>
            `import { default as Layout$${index} } from "${
              toFileUrl(
                fsContext.resolveFromOutDir('client', layout.hash + '.jsx'),
              )
            }";`,
        )
        .join('\n')
    }

    const layouts = ${
      pageConfig?.skipInheritedLayouts ? '[]' : `[
              ${
        layouts
          .map(
            (layout, index) =>
              `{ Layout: Layout$${index} as ComponentType<LayoutProps>, hash: "${layout.hash}" }`,
          )
          .join(',')
      }
            ]`
    };

    bootstrap({ Page, hash: "${hash}", layouts });
  `;

    await Deno.writeTextFile(hydrationFilePath, hydrationFileContent);
  }

  return {
    hydration: hydrationFilePath,
    hash,
    pageConfig: pageConfig ?? {},
  };
}

async function bundleAssets(context: FsContext) {
  await Promise.all([
    copyPublicFiles(context),
  ]);
}

async function copyPublicFiles(context: FsContext): Promise<void> {
  const publicDir = context.resolvePath('public');
  const publicDirExits = await exists(publicDir);

  if (!publicDirExits) {
    return;
  }

  const outDir = context.resolveFromOutDir('static');

  for await (const file of walk(publicDir, { includeDirs: false })) {
    const relativePath = relative(publicDir, file.path);
    const outDirDir = join(outDir, relativePath.slice(0, -file.name.length));
    await Deno.mkdir(outDirDir, {
      recursive: true,
    });
    await Deno.copyFile(file.path, resolve(outDir, relativePath));
  }
}

async function initializeBuildContext({
  entryPoints,
  define = {},
  outDir,
  plugins = [],
  fsContext,
  alias,
  mode,
  external = [],
}: {
  entryPoints: string[];
  outDir: string;
  fsContext: FsContext;
  define?: Record<string, string>;
  plugins?: esbuild.Plugin[];
  alias?: Record<string, string>;
  mode: Mode;
  external?: string[];
}) {
  await createDirectoryIfNotExists(outDir);

  const absWorkingDir = fsContext.resolvePath('.');

  const ctx = await esbuild.context({
    plugins: [
      ...plugins,
      ...denoPlugins({
        configPath: fsContext.resolvePath('./deno.json'),
      }),
    ],

    absWorkingDir,

    platform: 'browser',

    format: 'esm',
    target: 'esnext',

    splitting: true,
    bundle: true,
    treeShaking: true,
    minify: true,

    sourcemap: mode === 'development',
    metafile: true,

    entryPoints,
    outdir: '.',

    legalComments: 'none',

    jsx: 'automatic',
    jsxImportSource: 'preact',

    define: {
      ...define,
    },

    alias,

    external,

    entryNames: '[name]',
    write: false,
  });

  return {
    async rebuild() {
      const { outputFiles = [] } = await ctx.rebuild();

      const paths: string[] = [];
      const promises: Promise<void>[] = [];
      for (const file of outputFiles) {
        const filePath = fsContext.resolveFromOutDir(
          'static',
          relative(absWorkingDir, file.path),
        );
        const fileAlreadyExists = await exists(filePath);
        if (fileAlreadyExists) {
          await Deno.remove(filePath);
        }
        promises.push(
          Deno.writeFile(filePath, file.contents, {
            createNew: true,
          }),
        );
        entryPoints.push(filePath);
      }

      await Promise.all(promises);

      // await esbuild.stop();

      return paths;
    },
  };
}

export async function prepareClientCode({ manifest, fsContext }: {
  manifest: Manifest;
  fsContext: FsContext;
}) {
  await createDirectoryIfNotExists(
    fsContext.resolveFromOutDir('outttt'),
  );

  const tmpOutDir = await Deno.makeTempDir({
    dir: fsContext.resolveFromOutDir('outttt'),
  });

  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.ESNext,
      moduleResolution: ModuleResolutionKind.NodeNext,
      module: ModuleKind.ESNext,
      jsx: ts.JsxEmit.Preserve,
      jsxImportSource: 'preact',
      outDir: tmpOutDir,
    },
  });

  for (const path of Object.keys(manifest.routes)) {
    const entryName = basename(path);

    const absEntryPath = path.slice(0, -entryName.length);

    const file = project.addSourceFileAtPath(path);

    file.getImportDeclarations().forEach((importDeclaration) => {
      const moduleSpecifier = importDeclaration.getModuleSpecifier();
      const moduleSpecifierText = moduleSpecifier.getText().slice(1, -1);
      if (moduleSpecifierText.startsWith('../')) {
        const modulePath = resolve(absEntryPath, moduleSpecifierText);
        importDeclaration.setModuleSpecifier(modulePath);
      }
    });

    file.getVariableDeclarations().forEach((v) => {
      if (v.isExported()) {
        v.remove();
      }
    });

    file.getFunctions().forEach((f) => {
      if (f.isExported() && !f.isDefaultExport()) {
        f.remove();
      }
    });

    file.getExportDeclarations().forEach((exportDeclaration) => {
      exportDeclaration.removeModuleSpecifier().remove();
    });

    file.fixUnusedIdentifiers();
  }

  await project.emit();

  const entryPoints: string[] = [];

  for await (
    const entry of walk(resolve(tmpOutDir, 'routes'), {
      match: [/\.js(x)$/],
    })
  ) {
    const containerRelativeDir = relative(
      tmpOutDir,
      entry.path.slice(0, -entry.name.length),
    );

    const extMap: Record<string, string> = {
      '.js': '.ts',
      '.jsx': '.tsx',
    };

    const jsExt = extname(entry.path);
    const tsExt = extMap[jsExt];

    const tsFilePath = entry.name.slice(0, -jsExt.length) + tsExt;

    const manifestRouteKey = `.${SEPARATOR}` + join(
      containerRelativeDir,
      tsFilePath,
    );

    if (!manifest.routes[manifestRouteKey]) {
      continue;
    }

    const [hash] = manifest.routes[manifestRouteKey];

    const outDir = fsContext.resolveFromOutDir('client');

    await createDirectoryIfNotExists(outDir);

    const outFile = join(outDir, `${hash}${jsExt}`);

    await Deno.copyFile(
      entry.path,
      outFile,
    );

    entryPoints.push(outFile);
  }

  return entryPoints;
}

class BuildContext {
  #project!: Project;

  #fsContext: FsContext;

  constructor(fsContext: FsContext) {
    this.#fsContext = fsContext;
  }

  #assertProjectInitialized() {
    if (!this.#project) {
      throw new Error('Project not initialized');
    }
  }

  async #addCollectionsToProject() {
  }

  #extractLayouts(routesEntries: WalkEntry[]) {
    const layouts: Map<string, {
      realPath: string;
      virtualPath: string;
    }> = new Map();
    for (const entry of routesEntries) {
      if (entry.name !== LAYOUT_FILE_NAME) {
        continue;
      }
      const absRouteFilePath = entry.path.slice(0, -entry.name.length);
      layouts.set(absRouteFilePath, {
        realPath: entry.path,
        virtualPath: this.#getVirtualPath(entry.path),
      });
    }
    return layouts;
  }

  async #addRoutesToProject() {
    this.#assertProjectInitialized();

    const filesInRoutes = await Array.fromAsync(
      this.#fsContext.walkRoutesDir(),
    );

    const layouts = this.#extractLayouts(filesInRoutes);

    for (const [, { realPath, virtualPath }] of layouts.entries()) {
      const sourceFile = this.#project.createSourceFile(
        virtualPath,
        await Deno.readTextFile(realPath),
      );
      this.#sanitizeFile(sourceFile, realPath);
    }

    const findWrappingLayouts = (routePath: string) => {
      const entryName = basename(routePath);
      const parts = routePath.slice(0, -entryName.length).split(SEPARATOR);
      let acc = SEPARATOR;
      const routeLayouts: string[] = [];
      for (const part of parts.slice(1, -1)) {
        acc += part + SEPARATOR;
        if (layouts.has(acc)) {
          routeLayouts.push(
            layouts.get(acc)!.virtualPath,
          );
        }
      }
      return routeLayouts;
    };

    for (const route of filesInRoutes) {
      if (wellKnownFileNames.has(basename(route.path))) {
        continue;
      }
      let routeLayouts = findWrappingLayouts(route.path);
      const routeVirtualPath = this.#getVirtualPath(route.path);
      const sourceFile = this.#project.createSourceFile(
        routeVirtualPath,
        await Deno.readTextFile(route.path),
      );
      this.#sanitizeFile(sourceFile, route.path);
      routeLayouts = routeLayouts.map(
        (virtualPath) => {
          const layoutDistVirtualRelativePath = '.' + SEPARATOR + relative(
            dirname(routeVirtualPath),
            virtualPath,
          );
          return this.#resolveOutExtension(layoutDistVirtualRelativePath);
        },
      );
      this.#addBootstrap(sourceFile, routeLayouts);
      sourceFile.formatText();
      sourceFile.fixUnusedIdentifiers();
    }
  }

  #projectSrcDir = SEPARATOR + 'src' + SEPARATOR;

  #projectDistDir = SEPARATOR + 'dist' + SEPARATOR;

  #getVirtualPath(absPath: string) {
    return this.#projectSrcDir +
      relative(this.#fsContext.resolvePath('.'), absPath);
  }

  #resolveOutExtension(path: string) {
    if (path.endsWith('.tsx')) {
      return path.slice(0, -4) + '.jsx';
    }
    return path.slice(0, -3) + '.js';
  }

  async initialize() {
    this.#project = new Project({
      compilerOptions: {
        target: ScriptTarget.ES2015,
        moduleResolution: ModuleResolutionKind.NodeNext,
        module: ModuleKind.NodeNext,
        jsx: ts.JsxEmit.Preserve,
        jsxImportSource: 'preact',
        outDir: this.#projectDistDir,
      },
      manipulationSettings: {
        quoteKind: QuoteKind.Single,
        indentationText: IndentationText.TwoSpaces,
        newLineKind: NewLineKind.CarriageReturnLineFeed,
        useTrailingCommas: false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
      },
      useInMemoryFileSystem: true,
    });

    // Create source file to main project structure
    this.#project.createSourceFile(
      '/src/index.ts',
      'export {}',
    );

    await this.#addRoutesToProject();
    // Add collections to project
    // TODO:

    // Save project and emit result in memory fs
    await this.#project.save();
    await this.#emit();

    // Debug result
    this.#listProjectDir('/');

    await this.#writeProjectToFileSystem(this.#projectDistDir);
  }

  #listProjectDir(path: string) {
    this.#assertProjectInitialized();
    const projectFileSystem = this.#project.getFileSystem();
    for (const entry of projectFileSystem.readDirSync(path)) {
      if (entry.isDirectory) {
        this.#listProjectDir(entry.name);
      } else {
        console.log(entry.name);
      }
    }
  }

  async #writeProjectToFileSystem(path: string) {
    const cookedDir = this.#fsContext.resolveFromOutDir('project');
    const projectFileSystem = this.#project.getFileSystem();
    for (const entry of projectFileSystem.readDirSync(path)) {
      const path = join(
        cookedDir,
        entry.name.slice(this.#projectDistDir.length),
      );
      if (entry.isDirectory) {
        await createDirectoryIfNotExists(path);
        await this.#writeProjectToFileSystem(entry.name);
      } else {
        await Deno.writeTextFile(
          path,
          await projectFileSystem.readFile(entry.name),
        );
      }
    }
  }

  async #emit() {
    this.#assertProjectInitialized();
    await this.#project.emit();
  }

  #addBootstrap(sourceFile: SourceFile, layouts: string[]) {
    const bootstrapMod = import.meta.resolve('./browser/bootstrap.ts');
    sourceFile.addImportDeclaration({
      moduleSpecifier: bootstrapMod,
      namedImports: ['bootstrap'],
    });
    const layoutImports: string[] = [];
    for (const [index, layout] of layouts.entries()) {
      const importName = `L${index}`;
      sourceFile.addImportDeclaration({
        moduleSpecifier: layout,
        defaultImport: importName,
      });
      layoutImports.push(`{ Layout: ${importName}, hash: "" }`);
    }
    const layoutsVarName = 'layouts';
    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [
        {
          name: layoutsVarName,
          initializer: `[${layoutImports.join(', ')}]`,
        },
      ],
    });
    const defaultExport = sourceFile.getDefaultExportSymbol();
    const declarations = defaultExport?.getDeclarations();
    if (!declarations) {
      return;
    }
    const [declaration] = declarations;
    if (declaration.getKind() !== SyntaxKind.FunctionDeclaration) {
      return;
    }
    const name = defaultExport?.getFullyQualifiedName();
    if (!name) {
      return;
    }
    const symbolName = name.split('".').at(-1);
    sourceFile.removeDefaultExport();
    sourceFile.addStatements(
      `bootstrap({ Page: ${symbolName}, hash: "", layouts: ${layoutsVarName} });`,
    );
  }

  #sanitizeFile(sourceFile: SourceFile, fsPath: string) {
    const entryName = basename(fsPath);

    const absEntryPath = fsPath.slice(0, -entryName.length);

    sourceFile.getImportDeclarations().forEach((importDeclaration) => {
      const moduleSpecifier = importDeclaration.getModuleSpecifier();
      const moduleSpecifierText = moduleSpecifier.getText().slice(1, -1);
      if (moduleSpecifierText.startsWith('../')) {
        const modulePath = resolve(absEntryPath, moduleSpecifierText);
        importDeclaration.setModuleSpecifier(modulePath);
      }
    });

    sourceFile.getVariableDeclarations().forEach((v) => {
      if (v.isExported()) {
        v.remove();
      }
    });

    sourceFile.getFunctions().forEach((f) => {
      if (f.isExported() && !f.isDefaultExport()) {
        f.remove();
      }
    });

    sourceFile.getExportDeclarations().forEach((exportDeclaration) => {
      exportDeclaration.removeModuleSpecifier().remove();
    });
  }
}

enum WatcherStatus {
  IDLE,
  WATCHING,
}

type Watcher = {
  status: WatcherStatus;
  watch(): Promise<void>;
  stop(): void;
};

type WatcherEventMap = {
  change: (event: Deno.FsEvent) => Promise<void> | void;
};

class BuildWatcher extends TypedEvents<WatcherEventMap> implements Watcher {
  readonly id = crypto.randomUUID();

  #watcher: Deno.FsWatcher | undefined;

  status = WatcherStatus.IDLE;

  constructor(
    private path: string,
  ) {
    super();
  }

  async watch() {
    if (this.status === WatcherStatus.WATCHING) {
      return;
    }
    this.#watcher = Deno.watchFs(this.path, {
      recursive: true,
    });
    const emit = debounce((event: Deno.FsEvent) => {
      this.emit('change', event);
    }, 200);
    for await (const event of this.#watcher) {
      emit(event);
    }
  }

  stop() {
    this.#watcher?.close();
    this.status = WatcherStatus.IDLE;
  }
}
